package com.ivt.flex.utils
{
import mx.collections.ArrayCollection;
import mx.utils.ArrayUtil;

	/**
	 * Performs functions on both arrays and Vectors. For all methods, the array parameter is of type Object.
	 * Do not abuse this. It is impossible to check if it is an array or vector, because Generic vectors (Vector.<Bleh>)
	 * are not Vectors (according to the 'is' deelio).
	 */
	public class HelperString
	{
		/*
		 * When sorting strings, if you just use a simple alphanumeric sort, then the number 10 will always come before
		 * 2, which is pretty counter intuitive. I managed to track down the code which prevents this incorrect sorting
		 * in the Nautilus file browser used in Ubuntu. It comes from the GLib file gunicollate.c, and here is the
		 * relevant documentation:
		 * 
		 *
		 * How it works:
		 *
		 * Split the filename into collatable substrings which do
		 * not contain [.0-9] and special-cased substrings. The collatable
		 * substrings are run through the normal g_utf8_collate_key() and the
		 * resulting keys are concatenated with keys generated from the
		 * special-cased substrings.
		 *
		 * Special cases: Dots are handled by replacing them with '\1' which
		 * implies that short dot-delimited substrings are before long ones,
		 * e.g.
		 *
		 * a\1a (a.a)
		 * a-\1a (a-.a)
		 * aa\1a (aa.a)
		 *
		 * Numbers are handled by prepending to each number d-1 superdigits
		 * where d = number of digits in the number and SUPERDIGIT is a
		 * character with an integer value higher than any digit (for instance
		 * ':'). This ensures that single-digit numbers are sorted before
		 * double-digit numbers which in turn are sorted separately from
		 * triple-digit numbers, etc. To avoid strange side-effects when
		 * sorting strings that already contain SUPERDIGITs, a '\2'
		 * is also prepended, like this
		 *
		 * file\21 (file1)
		 * file\25 (file5)
		 * file\2:10 (file10)
		 * file\2:26 (file26)
		 * file\2::100 (file100)
		 * file:foo (file:foo)
		 *
		 * This has the side-effect of sorting numbers before everything else (except
		 * dots), but this is probably OK.
		 *
		 * Leading digits are ignored when doing the above. To discriminate
		 * numbers which differ only in the number of leading digits, we append
		 * the number of leading digits as a byte at the very end of the collation
		 * key.
		 *
		 * To try avoid conflict with any collation key sequence generated by libc we
		 * start each switch to a special cased part with a sentinel that hopefully
		 * will sort before anything libc will generate.
		 */
		public static function toSortFriendlyString( value:String ):String
		{
			if ( value == null )
			{
				return "";
			}
			else
			{
				// Split into substrings containing numbers...
				var re:RegExp = /(\d+)/;
				var parts:Array = value.split( re );

				for ( var i:int = 0; i < parts.length; i ++ )
				{
					var part:String = parts[ i ];
					if ( !isNaN( parseInt( part ) ) )
					{
						var superDigits:int = part.length - 1;
						for ( var j:int = 0; j < superDigits; j ++ )
						{
							part = ":" + part;
						}
						parts[ i ] = part;
					}
				}

				return parts.join( "" );
			}
		}

		/**
		 * Returns the value in lower camel case form.
		 * @param value The value to be converted.
		 * @return
		 */
		public static function lowerCamelCase( value:String ):String
		{
			return HelperString.camelCase( value, false );
		}

		/**
		 * Returns the value in upper camel case form.
		 * @param value The value to be converted.
		 * @return
		 */
		public static function upperCamelCase( value:String ):String
		{
			return HelperString.camelCase( value, true );
		}

		/**
		 * Returns the value in camel case form.
		 * Words are delimited by space, hyphen or underscore.
		 * @param value The value to be converted.
		 * @param upperFirstLetter Determines if the first letter should be upper or lower case.
		 * @return
		 */
		private static function camelCase( value:String, upperFirstLetter:Boolean ):String
		{
			if( null == value || value.length == 0 )
			{
				return "";
			}

			if( upperFirstLetter )
			{
				value = value.substr( 0, 1 ).toUpperCase() + value.substr( 1 );
			}
			else
			{
				value = value.substr( 0, 1 ).toLowerCase() + value.substr( 1 );
			}

			var regex:RegExp = /[ \-_]/;
			var words:Array = value.split( regex );
			for( var ii:int = 1; ii < words.length; ii++ )
			{
				var word:String = words[ ii ];
				words[ ii ] = word.substr( 0, 1 ).toUpperCase() + word.substr( 1 );
			}

			return words.join( "" );
		}
		
		public static function pluralize(value:String):String
		{
			if (value == null || value.length == 0)
			{
				return "";
			}
			else
			{
				if (value.charAt(value.length - 1) == "y")
				{
					return value.substr(0, value.length - 1) + "ies";
				}
				else
				{
					return value+"s";
				}
			}
		}

		/* Convert a plural into a singular
		 * TODO: Make this A LOT smarter than it is.
		 */
		public static function singularize( value:String ):String
		{
			if( value == null || value.length == 0 )
			{
				return "";
			}
			else
			{
				if( value.charAt( value.length - 1 ) == "s" )
				{
					return value.substr( 0, value.length - 1 );
				}
				else
				{
					return value;
				}
			}
		}

		public static function cleanHTML( html:String ):String
		{
			var pattern:RegExp = /<TEXTFORMAT.*?>/g;
			var str:String = html.replace(pattern, "");
			pattern = /<FONT.*?>/g;
			str = str.replace(pattern, ""); 
			pattern = /<\/FONT.*?>/g;
			str = str.replace(pattern, ""); 
			pattern = /<\/TEXTFORMAT.*?>/g;
			str = str.replace(pattern, ""); 
			
			return str;
		}
		
		public static function ucFirst( text:String ):String
		{
			return text.charAt( 0 ).toUpperCase() + text.substr( 1 );
		}

		/**
		 * Calculates the Levenshtein distance between two strings.
		 * The distance is the minimum number of edits needed to transform
		 * FIRST into SECOND with the allowable edits being insertion,
		 * deletion, or substitution of a single character.
		 *
		 * See: http://en.wikipedia.org/wiki/Levenshtein_distance
		 */
		public static function distance( first:String, second:String ):int
		{
			var ii:int;
			var jj:int;
			var dist:Array = new Array( first.length + 1 );

			for( ii = 0; ii <= first.length; ii++ )
			{
				dist[ ii ] = new Array( second.length + 1 );
				dist[ ii ][ 0 ] = ii;
			}

			for( jj = 1; jj <= second.length; jj++ )
			{
				dist[ 0 ][ jj ] = jj;
			}

			for( jj = 1; jj <= second.length; jj++ )
			{
				for( ii = 1; ii <= first.length; ii++ )
				{
					if( first.charAt( ii - 1 ) == second.charAt( jj - 1 ) )
					{
						dist[ ii ][ jj ] = dist[ ii - 1 ][ jj - 1 ];
					}
					else
					{
						dist[ ii ][ jj ] = Math.min( dist[ ii - 1 ][ jj ] + 1,       // Deletion
						                             dist[ ii ][ jj - 1 ] + 1,       // Insertion
						                             dist[ ii - 1 ][ jj - 1 ] + 1 ); // Substitution
					}
				}
			}

			return dist[ first.length ][ second.length ];
		}
	}
}